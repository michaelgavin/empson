% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/find_analogies.R
\name{find_analogies}
\alias{find_analogies}
\title{Multiply and divide word vectors}
\usage{
find_analogies(mat, positive = NULL, negative = NULL, operation = "*",
  sorted = T, exclude = T)
}
\description{
Performs basic word calculations to find analogous terms using a vector-offset method.
}
\section{Slots}{

\describe{
\item{\code{mat}}{A word-context matrix (format either matrix or \code{docMatrix}).}

\item{\code{positive}}{A character vector of terms to multiply/add.}

\item{\code{negative}}{A character vector of terms to divide/subtract.}

\item{\code{operation}}{A character vector (either "+" or "*"), that controls whether the vectors
                will be added as simple sums or as products. Default is "*".}

\item{\code{exclude}}{A logical value. If TRUE, the computed terms ('positive' and 'negative') will
              be excluded from the results.}
}}
\section{What it does}{

This function finds analogies by entering word vectors into a simple proportional equation. For
example, the analogy 'king':'queen'::'man':'woman' can be represented as
\deqn{V('king') / V('queen') ~= V('man') / V('woman') }

Of course, with vector-space models these equations are never exact, so what you're looking
for is not a precise equivalence, but a vector of candidates that might best fill the
analogy. If we re-state the above formula as \eqn{A/B = C/D}, then given three word vectors,
A, B, and C, we should be able to guess the best candidates for D. The equation \eqn{A/B = C/D}
can be converted to \eqn{C * B / A = D}.

When using the \code{find_analogies} function to seek out analogies in this way, enter your
search term in this (reverse) order:

\code{find_analogies(mat = eebo, positive = c("man","queen"), negative = "king")}

\strong{Notice that you have to enter your 'A' term as the 'negative' parameter.}

This returns "woman" as the first result. If you reverse the terms, such that you're looking
for the analogy \eqn{man:woman::king:?}, enter it this way:

\code{find_analogies(mat = eebo, positive = c("king","woman"), negative = "man")}

This returns some queens' names, and "queen" is the fourth result.

Results are similar when using addition and subtraction, but I have found results to be
sharper using multiplication, and the representation of analogies as fractions makes
more intuitive sense as an analogy for analogy, at least to me.

However, it's really not super precise. It struggles with analytical thinking, like
part-whole relationships.
}
\examples{
data(eebo)
# 'arteries':'veins' for words that exist together in a common category
find_analogies(mat = eebo, positive = c("liberties", "veins"), negative = "arteries")

# 'red':'yellow' captures something really interesting (not sure what)
# about 'prejudice' and its relation to rights/liberties/privileges
find_analogies(mat = eebo, positive = c("rights", "yellow"), negative = "red")
find_analogies(mat = eebo, positive = c("liberties", "yellow"), negative = "red")
find_analogies(mat = eebo, positive = c("privileges", "yellow"), negative = "red")

# contrast to 'yellow':'red'
find_analogies(mat = eebo, positive = c("rights", "red"), negative = "yellow")
find_analogies(mat = eebo, positive = c("liberties", "red"), negative = "yellow")
find_analogies(mat = eebo, positive = c("privileges", "red"), negative = "yellow")

# 'husband':'wife' for antonyms
find_analogies(mat = eebo, positive = c("heaven", "wife"), negative = "husband")
find_analogies(mat = eebo, positive = c("good", "wife"), negative = "husband")

# 'husband':'marriage' for (not sure how to characterize it, really)
find_analogies(mat = eebo, positive = c("coronation", "marriage"), negative = "husband")
find_analogies(mat = eebo, positive = c("ordination", "marriage"), negative = "husband")

# Were sherriffs elected in the seventeenth century?
find_analogies(mat = eebo, positive = c("election", "king"), negative = "succession")
find_analogies(mat = eebo, positive = c("election", "king"), negative = "coronation")

# 'members':'parliament' captures frequent co-occurence, though not necessarily
# "A of B" locutions:
find_analogies(mat = eebo, positive = c("church", "parliament"), negative = "members")
find_analogies(mat = eebo, positive = c("king", "parliament"), negative = "members")
}

